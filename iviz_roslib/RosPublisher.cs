using System;
using System.Collections.Concurrent;
using System.Collections.Generic;
using System.Linq;
using System.Net;
using System.Threading;
using System.Threading.Tasks;
using Iviz.Msgs;
using Iviz.XmlRpc;

namespace Iviz.Roslib
{
    /// <summary>
    /// Manager for a ROS publisher.
    /// </summary>
    /// <typeparam name="T">Topic type</typeparam>
    public class RosPublisher<T> : IRosPublisher<T> where T : IMessage
    {
        readonly CancellationTokenSource runningTs = new CancellationTokenSource();
        readonly TcpSenderManager<T> manager;
        readonly List<string> ids = new List<string>();
        readonly RosClient client;
        int totalPublishers;
        bool disposed;

        /// <summary>
        /// A cancellation token that gets canceled when the publisher is disposed.
        /// </summary>
        public CancellationToken CancellationToken => runningTs.Token;

        /// <summary>
        /// Whether this publisher is valid.
        /// </summary>
        public bool IsAlive => !CancellationToken.IsCancellationRequested;
        public string Topic => manager.Topic;
        public string TopicType => manager.TopicType;
        public int NumSubscribers => manager.NumConnections;

        /// <summary>
        /// The number of ids generated by this publisher.
        /// </summary>
        public int NumIds => ids.Count;

        /// <summary>
        /// Whether latching is enabled. When active, new subscribers will automatically receive a copy of the last message sent.
        /// </summary>
        public bool LatchingEnabled
        {
            get => manager.Latching;
            set => manager.Latching = value;
        }

        /// <summary>
        /// The queue size in bytes.
        /// If a message arrives that makes the queue larger than this, the oldest message will be discarded.
        /// </summary>
        public int MaxQueueSizeInBytes
        {
            get => manager.MaxQueueSizeInBytes;
            set => manager.MaxQueueSizeInBytes = value;
        }


        public int TimeoutInMs
        {
            get => manager.TimeoutInMs;
            set => manager.TimeoutInMs = value;
        }

        /// <summary>
        /// Called when the number of subscribers has changed.
        /// </summary>        
        public event Action<RosPublisher<T>>? NumSubscribersChanged;

        internal RosPublisher(RosClient client, TopicInfo<T> topicInfo)
        {
            this.client = client;
            manager = new TcpSenderManager<T>(this, topicInfo);
        }

        internal void RaiseNumConnectionsChanged()
        {
            NumSubscribersChanged?.Invoke(this);
        }

        void AssertIsAlive()
        {
            if (!IsAlive)
            {
                throw new ObjectDisposedException("This is not a valid publisher");
            }
        }

        string GenerateId()
        {
            string newId = totalPublishers == 0 ? Topic : $"{Topic}-{totalPublishers}";
            totalPublishers++;
            return newId;
        }

        public PublisherTopicState GetState()
        {
            AssertIsAlive();
            return new PublisherTopicState(Topic, TopicType, ids, manager.GetStates());
        }

        void IRosPublisher.Publish(IMessage message)
        {
            if (message is null)
            {
                throw new ArgumentNullException(nameof(message));
            }

            if (!MessageTypeMatches(message.GetType()))
            {
                throw new InvalidMessageTypeException("Type does not match publisher.");
            }

            message.RosValidate();
            AssertIsAlive();
            manager.Publish((T) message);
        }

        async Task IRosPublisher.PublishAsync(IMessage message)
        {
            if (message is null)
            {
                throw new ArgumentNullException(nameof(message));
            }

            if (!MessageTypeMatches(message.GetType()))
            {
                throw new InvalidMessageTypeException("Type does not match publisher.");
            }

            message.RosValidate();
            AssertIsAlive();
            await manager.PublishAsync((T) message);
        }


        /// <summary>
        /// Publishes the given message into the topic. 
        /// </summary>
        /// <param name="message">The message to be published.</param>
        /// <exception cref="ArgumentNullException">The message is null</exception>
        /// <exception cref="InvalidMessageTypeException">The message type does not match.</exception>        
        public void Publish(T message)
        {
            if (message == null)
            {
                throw new ArgumentNullException(nameof(message));
            }

            AssertIsAlive();
            message.RosValidate();
            manager.Publish(message);
        }

        public async Task PublishAsync(T message)
        {
            if (message == null)
            {
                throw new ArgumentNullException(nameof(message));
            }

            AssertIsAlive();
            message.RosValidate();
            await manager.PublishAsync(message);
        }

        Endpoint? IRosPublisher.RequestTopicRpc(string remoteCallerId)
        {
            Endpoint? localEndpoint = manager.CreateConnectionRpc(remoteCallerId);
            return localEndpoint == null ? null : new Endpoint(client.CallerUri.Host, localEndpoint.Port);
        }

        void IDisposable.Dispose()
        {
            Dispose();
        }

        void Dispose()
        {
            if (disposed)
            {
                return;
            }

            disposed = true;
            runningTs.Cancel();
            ids.Clear();
            manager.Stop();
            NumSubscribersChanged = null;
        }
        
        public async Task DisposeAsync()
        {
            if (disposed)
            {
                return;
            }

            disposed = true;
            runningTs.Cancel();
            ids.Clear();
            await manager.StopAsync().AwaitNoThrow(this);
            NumSubscribersChanged = null;
        }        

        public string Advertise()
        {
            AssertIsAlive();

            string id = GenerateId();
            ids.Add(id);

#if DEBUG__
            Logger.LogDebug($"{this}: Advertising '{Topic}' with type {TopicType} and id '{id}'");
#endif

            return id;
        }

        bool RemoveId(string topicId)
        {
            if (topicId is null)
            {
                throw new ArgumentNullException(nameof(topicId));
            }

            return ids.Remove(topicId);
        }

        public bool Unadvertise(string id)
        {
            if (!IsAlive)
            {
                return true;
            }

            bool removed = RemoveId(id);

            if (ids.Count == 0)
            {
                Dispose();
                client.RemovePublisher(this);
            }

            return removed;
        }

        public async Task<bool> UnadvertiseAsync(string id)
        {
            if (!IsAlive)
            {
                return true;
            }

            bool removed = RemoveId(id);

            if (ids.Count == 0)
            {
                await DisposeAsync().AwaitNoThrow(this);
                await client.RemovePublisherAsync(this).AwaitNoThrow(this);
            }

            return removed;
        }

        public bool ContainsId(string id)
        {
            if (id is null)
            {
                throw new ArgumentNullException(nameof(id));
            }

            return ids.Contains(id);
        }

        public bool MessageTypeMatches(Type type)
        {
            return type == typeof(T);
        }

        public override string ToString()
        {
            return $"[Publisher {Topic} [{TopicType}] ]";
        }

        public void WaitForAnySubscriber(int timeoutInMs)
        {
            CancellationTokenSource timeoutTs = new CancellationTokenSource(timeoutInMs);
            try
            {
                Task.Run(async () => await WaitForAnySubscriberAsync(timeoutTs.Token), timeoutTs.Token)
                    .Wait(timeoutTs.Token);
            }
            catch (AggregateException e) when (e.InnerException is OperationCanceledException)
            {
                throw e.InnerException;
            }
        }

        public async Task WaitForAnySubscriberAsync(CancellationToken token)
        {
            CancellationTokenSource linkedTs =
                CancellationTokenSource.CreateLinkedTokenSource(token, CancellationToken);
            using SemaphoreSlim signal = new SemaphoreSlim(0, 1);
            void Release(RosPublisher<T> _) => signal.Release();
            NumSubscribersChanged += Release;

            try
            {
                if (NumSubscribers != 0)
                {
                    return;
                }

                await signal.WaitAsync(linkedTs.Token);
            }
            finally
            {
                NumSubscribersChanged -= Release;
            }
        }
    }
}