using System;
using System.Collections.Concurrent;
using System.Collections.Generic;
using System.Linq;
using System.Threading.Tasks;
using Iviz.Msgs;
using Iviz.XmlRpc;

namespace Iviz.Roslib
{
    /// <summary>
    /// Class that manages a subscription to a ROS topic.
    /// </summary>
    public class RosSubscriber
    {
        readonly ConcurrentDictionary<string, Action<IMessage>> callbacksById =
            new ConcurrentDictionary<string, Action<IMessage>>();

        readonly TcpReceiverManager manager;
        readonly RosClient client;
        readonly Type topicClassType;

        int totalSubscribers;

        /// <summary>
        /// Whether this subscriber is valid.
        /// </summary>
        public bool IsAlive { get; private set; }

        /// <summary>
        /// The name of the topic.
        /// </summary>
        public string Topic => manager.Topic;

        /// <summary>
        /// The ROS message type of the topic.
        /// </summary>
        public string TopicType => manager.TopicType;

        /// <summary>
        /// The number of publishers in the topic.
        /// </summary>
        public int NumPublishers => manager.NumConnections;

        /// <summary>
        /// The number of ids generated by this subscriber.
        /// </summary>
        public int NumIds => callbacksById.Count;

        /// <summary>
        /// Whether the TCP_NODELAY flag was requested.
        /// </summary>
        public bool RequestNoDelay => manager.RequestNoDelay;

        /// <summary>
        /// Event triggered when a new publisher appears.
        /// </summary>
        public event Action<RosSubscriber> NumPublishersChanged;

        /// <summary>
        /// Timeout in milliseconds to wait for a publisher handshake.
        /// </summary>
        public int TimeoutInMs
        {
            get => manager.TimeoutInMs;
            set => manager.TimeoutInMs = value;
        }

        internal RosSubscriber(RosClient client, TcpReceiverManager manager)
        {
            this.client = client;
            this.manager = manager;
            topicClassType = manager.TopicInfo.Generator.GetType();
            IsAlive = true;

            manager.Subscriber = this;
        }

        internal void MessageCallback(IMessage msg)
        {
            foreach (Action<IMessage> callback in callbacksById.Values)
            {
                callback(msg);
            }
        }

        string GenerateId()
        {
            string newId = totalSubscribers == 0 ? Topic : $"{Topic}-{totalSubscribers}";
            totalSubscribers++;
            return newId;
        }

        void AssertIsAlive()
        {
            if (!IsAlive)
            {
                throw new ObjectDisposedException("This is not a valid subscriber");
            }
        }

        public SubscriberTopicState GetState()
        {
            AssertIsAlive();
            return new SubscriberTopicState(Topic, TopicType, callbacksById.Keys.ToArray(), manager.GetStates());
        }

        internal async Task PublisherUpdateRcpAsync(IEnumerable<Uri> publisherUris)
        {
            if (await manager.PublisherUpdateRpcAsync(client, publisherUris).Caf())
            {
                NumPublishersChanged?.Invoke(this);
            }
        }

        internal void Stop()
        {
            callbacksById.Clear();
            manager.Stop();
            NumPublishersChanged = null;
            IsAlive = false;
        }

        public bool MessageTypeMatches(Type type)
        {
            return type == topicClassType;
        }

        public string Subscribe(Action<IMessage> callback)
        {
            if (callback is null)
            {
                throw new ArgumentNullException(nameof(callback));
            }

            AssertIsAlive();

#if DEBUG__
            Logger.LogDebug($"{this}: Subscribing to '{Topic}' with type '{TopicType}'");
#endif

            string id = GenerateId();
            callbacksById.TryAdd(id, callback);
            return id;
        }

        public bool ContainsId(string id)
        {
            if (id is null)
            {
                throw new ArgumentNullException(nameof(id));
            }

            return callbacksById.ContainsKey(id);
        }

        public bool Unsubscribe(string id)
        {
            if (id is null) { throw new ArgumentNullException(nameof(id)); }

            AssertIsAlive();
            bool removed = callbacksById.TryRemove(id, out _);

            if (callbacksById.Count == 0)
            {
                Stop();
                client.RemoveSubscriber(this);
            }

            return removed;
        }

        public async Task<bool> UnsubscribeAsync(string id)
        {
            if (id is null) { throw new ArgumentNullException(nameof(id)); }

            AssertIsAlive();
            bool removed = callbacksById.TryRemove(id, out _);

            if (callbacksById.Count == 0)
            {
                Stop();
                await client.RemoveSubscriberAsync(this);
            }

            return removed;
        }

        public override string ToString()
        {
            return $"[Subscriber {Topic} [{TopicType}] ]";
        }
    }
}