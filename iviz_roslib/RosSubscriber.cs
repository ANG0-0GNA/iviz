using System;
using System.Collections.Concurrent;
using System.Collections.Generic;
using System.Linq;
using System.Threading.Tasks;
using Iviz.Msgs;
using Iviz.XmlRpc;

namespace Iviz.Roslib
{
    /// <summary>
    /// Class that manages a subscription to a ROS topic.
    /// </summary>
    public class RosSubscriber
    {
        readonly ConcurrentDictionary<string, Action<IMessage>> callbacksById =
            new ConcurrentDictionary<string, Action<IMessage>>();

        readonly TcpReceiverManager manager;
        readonly RosClient client;
        readonly Type topicClassType;

        int totalSubscribers;

        /// <summary>
        /// Whether this subscriber is valid.
        /// </summary>
        public bool IsAlive { get; private set; }

        /// <summary>
        /// The name of the topic.
        /// </summary>
        public string Topic => manager.Topic;

        /// <summary>
        /// The ROS message type of the topic.
        /// </summary>
        public string TopicType => manager.TopicType;

        /// <summary>
        /// The number of publishers in the topic.
        /// </summary>
        public int NumPublishers => manager.NumConnections;

        /// <summary>
        /// The number of ids generated by this subscriber.
        /// </summary>
        public int NumIds => callbacksById.Count;

        /// <summary>
        /// Whether the TCP_NODELAY flag was requested.
        /// </summary>
        public bool RequestNoDelay => manager.RequestNoDelay;

        /// <summary>
        /// Event triggered when a new publisher appears.
        /// </summary>
        public event Action<RosSubscriber> NumPublishersChanged;

        /// <summary>
        /// Timeout in milliseconds to wait for a publisher handshake.
        /// </summary>
        public int TimeoutInMs
        {
            get => manager.TimeoutInMs;
            set => manager.TimeoutInMs = value;
        }

        internal RosSubscriber(RosClient client, TcpReceiverManager manager)
        {
            this.client = client;
            this.manager = manager;
            topicClassType = manager.TopicInfo.Generator.GetType();
            IsAlive = true;

            manager.NumConnectionsChanged += () => NumPublishersChanged?.Invoke(this);
            manager.Subscriber = this;
        }

        internal void MessageCallback(IMessage msg)
        {
            foreach (Action<IMessage> callback in callbacksById.Values)
            {
                callback(msg);
            }
        }

        string GenerateId()
        {
            string newId = totalSubscribers == 0 ? Topic : $"{Topic}-{totalSubscribers}";
            totalSubscribers++;
            return newId;
        }

        void AssertIsAlive()
        {
            if (!IsAlive)
            {
                throw new ObjectDisposedException("This is not a valid subscriber");
            }
        }

        /// <summary>
        /// Returns a structure that represents the internal state of the subscriber. 
        /// </summary>   
        public SubscriberTopicState GetState()
        {
            AssertIsAlive();
            return new SubscriberTopicState(Topic, TopicType, callbacksById.Keys.ToArray(), manager.GetStates());
        }

        internal async Task PublisherUpdateRcpAsync(IEnumerable<Uri> publisherUris)
        {
            await manager.PublisherUpdateRpcAsync(client, publisherUris).Caf();
        }

        internal void Stop()
        {
            callbacksById.Clear();
            manager.Stop();
            NumPublishersChanged = null;
            IsAlive = false;
        }

        /// <summary>
        /// Checks whether the class of the subscriber message type corresponds to the given type.
        /// </summary>
        /// <param name="type">The type to check.</param>
        /// <returns>Whether the class type matches.</returns>
        public bool MessageTypeMatches(Type type)
        {
            return type == topicClassType;
        }

        /// <summary>
        /// Checks whether the class of the subscriber message type corresponds to the given type.
        /// </summary>
        /// <typeparam name="T">The type to check.</typeparam>
        /// <returns></returns>
        public bool MessageTypeMatches<T>()
        {
            return MessageTypeMatches(typeof(T));
        }

        /// <summary>
        /// Generates a new subscriber id with the given callback function.
        /// </summary>
        /// <param name="callback">The function to call when a message arrives.</param>
        /// <returns>The subscribed id.</returns>
        /// <exception cref="ArgumentNullException">The callback is null.</exception>
        public string Subscribe(Action<IMessage> callback)
        {
            if (callback is null) { throw new ArgumentNullException(nameof(callback)); }

            AssertIsAlive();

#if DEBUG__
            Logger.LogDebug($"{this}: Subscribing to '{Topic}' with type '{TopicType}'");
#endif

            string id = GenerateId();
            callbacksById.TryAdd(id, callback);
            return id;
        }

        /// <summary>
        /// Generates a new subscriber id with the given callback function.
        /// </summary>
        /// <param name="callback">The function to call when a message arrives.</param>
        /// <typeparam name="T">The message type</typeparam>
        /// <returns>The subscribed id.</returns>
        /// <exception cref="ArgumentNullException">The callback is null.</exception>
        /// <exception cref="InvalidMessageTypeException">The argument type of the callback does not match.</exception>
        public string Subscribe<T>(Action<T> callback) where T : IMessage
        {
            if (callback is null) { throw new ArgumentNullException(nameof(callback)); }

            if (!MessageTypeMatches<T>())
            {
                throw new InvalidMessageTypeException("Type does not match publisher.");
            }

            // local lambda wrapper for casting
            void Wrapper(IMessage x)
            {
                callback((T) x);
            }

            return Subscribe(Wrapper);
        }

        /// <summary>
        /// Checks whether this subscriber has provided the given id from a Subscribe() call.
        /// </summary>
        /// <param name="id">Identifier to check.</param>
        /// <returns>Whether the id was provided by this subscriber.</returns>   
        public bool ContainsId(string id)
        {
            if (id is null) { throw new ArgumentNullException(nameof(id)); }

            return callbacksById.ContainsKey(id);
        }

        /// <summary>
        /// Unregisters the given id from the subscriber. If the subscriber has no ids left, the topic will be unsubscribed from the master.
        /// </summary>
        /// <param name="id">The id to be unregistered.</param>
        /// <returns>Whether the id belonged to the subscriber.</returns>
        public bool Unsubscribe(string id)
        {
            if (id is null) { throw new ArgumentNullException(nameof(id)); }

            AssertIsAlive();
            bool removed = callbacksById.TryRemove(id, out _);

            if (callbacksById.Count == 0)
            {
                Stop();
                client.RemoveSubscriber(this);
            }

            return removed;
        }

        /// <summary>
        /// Unregisters the given id from the subscriber. If the subscriber has no ids left, the topic will be unsubscribed from the master.
        /// </summary>
        /// <param name="id">The id to be unregistered.</param>
        /// <returns>Whether the id belonged to the subscriber.</returns>
        public async Task<bool> UnsubscribeAsync(string id)
        {
            if (id is null) { throw new ArgumentNullException(nameof(id)); }

            AssertIsAlive();
            bool removed = callbacksById.TryRemove(id, out _);

            if (callbacksById.Count == 0)
            {
                Stop();
                await client.RemoveSubscriberAsync(this);
            }

            return removed;
        }

        public override string ToString()
        {
            return $"[Subscriber {Topic} [{TopicType}] ]";
        }
    }
}