using System;
using System.Collections.Concurrent;
using System.Collections.Generic;
using System.Linq;
using System.Threading.Tasks;
using Iviz.Msgs;
using Iviz.XmlRpc;

namespace Iviz.Roslib
{
    /// <summary>
    /// Interface for all ROS subscribers.
    /// </summary>
    public interface IRosSubscriber
    {
        /// <summary>
        /// Timeout in milliseconds to wait for a publisher handshake.
        /// </summary>
        public int TimeoutInMs { get; set; }

        /// <summary>
        /// The name of the topic.
        /// </summary>        
        public string Topic { get; }

        /// <summary>
        /// The ROS message type of the topic.
        /// </summary>        
        public string TopicType { get; }

        /// <summary>
        /// The number of publishers in the topic.
        /// </summary>
        public int NumPublishers { get; }

        /// <summary>
        /// Returns a structure that represents the internal state of the subscriber. 
        /// </summary>           
        public SubscriberTopicState GetState();

        /// <summary>
        /// Checks whether this subscriber has provided the given id from a Subscribe() call.
        /// </summary>
        /// <param name="id">Identifier to check.</param>
        /// <returns>Whether the id was provided by this subscriber.</returns>        
        public bool ContainsId(string id);

        /// <summary>
        /// Checks whether the class of the subscriber message type corresponds to the given type.
        /// </summary>
        /// <param name="type">The type to check.</param>
        /// <returns>Whether the class type matches.</returns>
        public bool MessageTypeMatches(Type type);

        /// <summary>
        /// Generates a new subscriber id with the given callback function.
        /// </summary>
        /// <param name="callback">The function to call when a message arrives.</param>
        /// <returns>The subscribed id.</returns>
        /// <exception cref="ArgumentNullException">The callback is null.</exception>
        public string Subscribe(Action<IMessage> callback);

        /// <summary>
        /// Unregisters the given id from the subscriber. If the subscriber has no ids left, the topic will be unsubscribed from the master.
        /// </summary>
        /// <param name="id">The id to be unregistered.</param>
        /// <returns>Whether the id belonged to the subscriber.</returns>        
        public bool Unsubscribe(string id);

        /// <summary>
        /// Unregisters the given id from the subscriber. If the subscriber has no ids left, the topic will be unsubscribed from the master.
        /// </summary>
        /// <param name="id">The id to be unregistered.</param>
        /// <returns>Whether the id belonged to the subscriber.</returns>        
        public Task<bool> UnsubscribeAsync(string id);

        internal void Stop();
        internal Task PublisherUpdateRcpAsync(IEnumerable<Uri> publisherUris);
    }

    /// <summary>
    /// Manager for a subscription to a ROS topic.
    /// </summary>
    public class RosSubscriber<T> : IRosSubscriber where T : IMessage
    {
        readonly Dictionary<string, Action<T>> callbacksById = new Dictionary<string, Action<T>>();
        readonly TcpReceiverManager<T> manager;
        readonly RosClient client;

        int totalSubscribers;

        /// <summary>
        /// Whether this subscriber is valid.
        /// </summary>
        public bool IsAlive { get; private set; }
        public string Topic => manager.Topic;
        public string TopicType => manager.TopicType;
        public int NumPublishers => manager.NumConnections;

        /// <summary>
        /// The number of ids generated by this subscriber.
        /// </summary>
        public int NumIds => callbacksById.Count;

        /// <summary>
        /// Whether the TCP_NODELAY flag was requested.
        /// </summary>
        public bool RequestNoDelay => manager.RequestNoDelay;

        /// <summary>
        /// Event triggered when a new publisher appears.
        /// </summary>
        public event Action<RosSubscriber<T>> NumPublishersChanged;

        public int TimeoutInMs
        {
            get => manager.TimeoutInMs;
            set => manager.TimeoutInMs = value;
        }

        internal RosSubscriber(RosClient client, TcpReceiverManager<T> manager)
        {
            this.client = client;
            this.manager = manager;
            IsAlive = true;

            manager.Subscriber = this;
        }

        internal void MessageCallback(in T msg)
        {
            foreach (Action<T> callback in callbacksById.Values)
            {
                try
                {
                    callback(msg);
                }
                catch (Exception e)
                {
                    Logger.LogError($"{this}: Exception from callback : {e}");
                }
            }
        }

        internal void RaiseNumPublishersChanged()
        {
            NumPublishersChanged?.Invoke(this);
        }

        string GenerateId()
        {
            string newId = totalSubscribers == 0 ? Topic : $"{Topic}-{totalSubscribers}";
            totalSubscribers++;
            return newId;
        }

        void AssertIsAlive()
        {
            if (!IsAlive)
            {
                throw new ObjectDisposedException("This is not a valid subscriber");
            }
        }

        public SubscriberTopicState GetState()
        {
            AssertIsAlive();
            return new SubscriberTopicState(Topic, TopicType, callbacksById.Keys.ToArray(), manager.GetStates());
        }

        async Task IRosSubscriber.PublisherUpdateRcpAsync(IEnumerable<Uri> publisherUris)
        {
            await manager.PublisherUpdateRpcAsync(publisherUris).Caf();
        }

        void IRosSubscriber.Stop()
        {
            Stop();
        }

        void Stop()
        {
            callbacksById.Clear();
            manager.Stop();
            NumPublishersChanged = null;
            IsAlive = false;
        }

        public bool MessageTypeMatches(Type type)
        {
            return type == typeof(T);
        }

        string IRosSubscriber.Subscribe(Action<IMessage> callback)
        {
            if (callback is null) { throw new ArgumentNullException(nameof(callback)); }

            AssertIsAlive();

#if DEBUG__
            Logger.LogDebug($"{this}: Subscribing to '{Topic}' with type '{TopicType}'");
#endif

            string id = GenerateId();
            callbacksById.Add(id, t => callback(t));
            return id;
        }

        /// <summary>
        /// Generates a new subscriber id with the given callback function.
        /// </summary>
        /// <param name="callback">The function to call when a message arrives.</param>
        /// <typeparam name="T">The message type</typeparam>
        /// <returns>The subscribed id.</returns>
        /// <exception cref="ArgumentNullException">The callback is null.</exception>
        public string Subscribe(Action<T> callback)
        {
            if (callback is null) { throw new ArgumentNullException(nameof(callback)); }

            string id = GenerateId();
            callbacksById.Add(id, callback);
            return id;
        }

        public bool ContainsId(string id)
        {
            if (id is null) { throw new ArgumentNullException(nameof(id)); }

            return callbacksById.ContainsKey(id);
        }

        public bool Unsubscribe(string id)
        {
            if (id is null) { throw new ArgumentNullException(nameof(id)); }

            AssertIsAlive();
            bool removed = callbacksById.Remove(id);

            if (callbacksById.Count == 0)
            {
                Stop();
                client.RemoveSubscriber(this);
            }

            return removed;
        }

        public async Task<bool> UnsubscribeAsync(string id)
        {
            if (id is null) { throw new ArgumentNullException(nameof(id)); }

            AssertIsAlive();
            bool removed = callbacksById.Remove(id);

            if (callbacksById.Count == 0)
            {
                Stop();
                await client.RemoveSubscriberAsync(this).Caf();
            }

            return removed;
        }

        public override string ToString()
        {
            return $"[Subscriber {Topic} [{TopicType}] ]";
        }
    }
}