using System;
using System.Diagnostics.CodeAnalysis;
using System.Runtime.InteropServices;
using Iviz.Msgs;

namespace Iviz.XmlRpc
{
    /// <summary>
    /// Contains an arbitrary object/value generated by an XML-RPC function.
    /// </summary>
    public readonly struct XmlRpcValue
    {
        public enum Type
        {
            Empty,
            Integer,
            Double,
            Boolean,
            DateTime,
            String,
            Array,
            Base64,
            Struct
        }

        readonly double d;
        readonly object? o;
        readonly Type type;

        public Type ValueType => type;
        public bool IsEmpty => type == Type.Empty;

        public XmlRpcValue(double d)
        {
            o = null;
            this.d = d;
            type = Type.Double;
        }

        public XmlRpcValue(bool b)
        {
            o = null;
            d = b ? 1 : 0;
            type = Type.Boolean;
        }

        public XmlRpcValue(int i)
        {
            o = null;
            d = i;
            type = Type.Integer;
        }

        public XmlRpcValue(string s)
        {
            d = 0;
            o = s;
            type = Type.String;
        }

        public XmlRpcValue(DateTime dt)
        {
            d = DoubleLongReinterpret.AsDouble(dt.Ticks);
            o = null;
            type = Type.DateTime;
        }

        public XmlRpcValue(byte[] bs)
        {
            d = 0;
            o = bs;
            type = Type.Base64;
        }

        public XmlRpcValue(XmlRpcValue[] os)
        {
            d = 0;
            o = os;
            type = Type.Array;
        }

        public XmlRpcValue((string Key, XmlRpcValue Value)[] vs)
        {
            d = 0;
            o = vs;
            type = Type.Struct;
        }

        public bool TryGetBoolean(out bool value)
        {
            if (type == Type.Boolean)
            {
                value = (d != 0);
                return true;
            }

            value = default;
            return false;
        }

        public bool TryGetDouble(out double value)
        {
            if (type == Type.Double)
            {
                value = d;
                return true;
            }

            value = default;
            return false;
        }

        public bool TryGetInteger(out int value)
        {
            if (type == Type.Integer)
            {
                value = (int) d;
                return true;
            }

            value = default;
            return false;
        }

        public bool TryGetString(out string value)
        {
            if (type == Type.String)
            {
                value = (string) o!;
                return true;
            }

            value = "";
            return false;
        }

        public bool TryGetDateTime(out DateTime value)
        {
            if (type == Type.DateTime)
            {
                value = new DateTime(DoubleLongReinterpret.AsLong(d));
                return true;
            }

            value = default;
            return false;
        }

        public bool TryGetBase64(out byte[] value)
        {
            if (type == Type.Base64)
            {
                value = (byte[]) o!;
                return true;
            }

            value = Array.Empty<byte>();
            return false;
        }

        public bool TryGetArray(out XmlRpcValue[] value)
        {
            if (type == Type.Array)
            {
                value = (XmlRpcValue[]) o!;
                return true;
            }

            value = Array.Empty<XmlRpcValue>();
            return false;
        }

        public bool TryGetStruct(out (string Key, XmlRpcValue Value)[] value)
        {
            if (type == Type.Struct)
            {
                value = ((string, XmlRpcValue)[]) o!;
                return true;
            }

            value = Array.Empty<(string, XmlRpcValue)>();
            return false;
        }

        public XmlRpcArg AsArg() => type switch
        {
            Type.Integer => (int) d,
            Type.Empty => throw new InvalidOperationException("Empty object"),
            Type.Double => d,
            Type.Boolean => d != 0,
            Type.DateTime => new DateTime(DoubleLongReinterpret.AsLong(d)),
            Type.String => (string) o!,
            Type.Array => ((XmlRpcValue[]) o!).Select(wrapper => wrapper.AsArg()).ToArray(),
            Type.Base64 => (byte[]) o!,
            Type.Struct => (((string Key, XmlRpcValue Value)[]) o!)
                .Select(entry => (entry.Key, entry.Value.AsArg())).ToArray(),
            _ => throw new ArgumentOutOfRangeException()
        };

        public override string ToString() => type switch
        {
            Type.Integer => $"[int:{((int)d).ToString()}]",
            Type.Empty => "[empty]",
            Type.Double => $"[double:{d.ToString(BuiltIns.Culture)}]",
            Type.Boolean => d != 0 ? "[bool:true]" : "[bool:false]",
            Type.DateTime => $"[datetime:{new DateTime(DoubleLongReinterpret.AsLong(d)).ToString(BuiltIns.Culture)}]",
            Type.String => $"[string:{(string) o!}]",
            Type.Array => $"[array:{((Array) o!).Length.ToString()} elems]",
            Type.Base64 => $"[base64:{((Array) o!).Length.ToString()} bytes]",
            Type.Struct => $"[struct:{((Array) o!).Length.ToString()} fields]",
            _ => throw new ArgumentOutOfRangeException()
        };

        [StructLayout(LayoutKind.Explicit)]
        readonly struct DoubleLongReinterpret
        {
            [FieldOffset(0)] readonly long l;
            [FieldOffset(0)] readonly double d;

            DoubleLongReinterpret(long ll) => (d, l) = (0, ll);
            DoubleLongReinterpret(double dd) => (l, d) = (0, dd);

            public static double AsDouble(long l) => new DoubleLongReinterpret(l).d;
            public static long AsLong(double d) => new DoubleLongReinterpret(d).l;
        }
    }
}